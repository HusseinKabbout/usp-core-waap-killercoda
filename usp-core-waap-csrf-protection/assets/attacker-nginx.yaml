apiVersion: v1
kind: Namespace
metadata:
  name:  attacker
---
apiVersion: v1
kind: Pod
metadata:
  name: attacker-nginx
  namespace: attacker
  labels:
    app.kubernetes.io/name: attacker
spec:
  containers:
  - name: attacker-nginx
    image: nginx:1.27.3
    resources:
      requests:
        memory: 128Mi
        cpu: 100m
      limits:
        memory: 512Mi
        cpu: 500m
    ports:
      - containerPort: 80
    volumeMounts:
      - mountPath: /usr/share/nginx/html
        name: webpage-volume
  volumes:
    - configMap:
        defaultMode: 0775
        name: index-page
      name: webpage-volume
---
apiVersion: v1
kind: Service
metadata:
  name: attacker-nginx
  namespace: attacker
spec:
  selector:
    app.kubernetes.io/name: attacker
  ports:
    - protocol: TCP
      port: 9090
      targetPort: 80
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: index-page
  namespace: attacker
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>CSRF Attack</title></head>
    
    <body>
    
    <h2>Juiceshop Username Hacking Form</h2>
    
    This HTML page, loaded from a different website than Juiceshop, will send a request to the Juiceshop without an "Origin"
    header (because it was not received from a website). The request attempts to change the "Username" in the
    profile page to "hacked".
    <p></p>
    <b>NOTE: </b> This attack requires that you are currently logged in at the Juiceshop in this webbrowser.
    Your existing session (in another tab or window) will be abused to send an "evil" request to Juiceshop
    to change the "Username" value.
    
    <p></p>
    <hr>
    <h3>Hacking Form - direct Juiceshop</h3>
    Submit form to hack "username" in Juiceshop
    <form id="hackingform" 
          action="empty" 
         method="POST">
        URL:<input id="juiceshopUrl" name="url" type="text" value="" /><br>
     Username:<input name="username" type="text" value="hacked" />
     <input type="submit" value="Hack Username" />
    </form>

    <script>    
        let juiceshopUrlField = document.getElementById("juiceshopUrl");
        let hackingForm = document.getElementById("hackingform");
        hackingForm.addEventListener("submit", (e) => {
          e.preventDefault();
          hackingForm.action = juiceshopUrlField.text + '/profile'
          // handle submit
        });
    </script>
    
    <h3>CSRF Protection</h3>
    <p></p>
    With Core-WAAP CSRF Policy enabled, that "evil" request will be blocked because it does not contain the required origin information  
    (as it originated on a different virtual host). Add this configuration in the Core WAAP configuration to enable the policy:
    <p></p>
    
    <pre>
      crs:
        mode: DISABLED
      csrfPolicy:
        enabled: true
    </pre>
    
    Note that this example also disables Coraza (crs) for the sake of this simple demo, because otherwise this
    attack would be prevented by the CRS filter as well.
    
    </body></html>
